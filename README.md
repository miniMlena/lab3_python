

В рекурсивном Фибоначчи использован декоратор @functools.cache, т.к. без него функция считала максимум 40 элемент

Бенчмарки в тестах показывают, что пузырьковая сортировка - самая быстрая, хотя обычно наоборот считается самой медленной. Все дело в ключах и компараторах, для поддержки которых в большинстве случаев необходимо ещё раз проходится по списку элементов, в некоторых случаях создавать дополнительный список значений для сортировки, проводить валидацию получившегося списка, банально применить ключ/компаратор и так далее. Все это тратит очень много времени. И особенность пузырьковой сортировки в том, что ее алгоритм не требует дополнительного прохода по списку или чего-то подобного. К тому же в моей реализации она останавливается, если никаких перестановок не произошло на каком-то из проходов, что позволяет раньше закончить процесс.

В бенчмарках есть и масштабируемость
в pytest бенчмарках все в перемешку

# Лабораторная работа 3
## Вариант: Medium (CLI, ключи, компараторы, бенчмарки, генерация тест-кейсов)

Моисеенко Милена Алексеевна, группа М8О-101БВ-25

* **Цель:** Написать функции подсчёта факториала, чисел Фибоначчи и сортировки списков с поддержкой ключей и компараторов на Python, реализовать одну из структур данных (я выбрала очередь), а также написать функции для бенчмарок и генераторы тест-койсов.
* **Библиотеки:** *typing*, *functools*, *sys*, *time*, *random*, *pytest*
* **Допущения:**
  - Элементами очередей и списков для сортировки могут быть только числа и строки. Вложенные списки/кортежи и т.д. не поддерживаются.
  - Можно пользоваться только предусмотренными в прграмме ключами и компараторами, свои создавать нельзя.
  - При тестировании бенчмарки для сортировок и факториалов/Фибоначчи выводятся вперемешку (там используются бенчмарки, встроенные в pytest). Чтобы посмотреть раздельные бенчмарки, можно ввести команду benchmark в самой программе (выведутся мои кастомные бенчмарки).

* **Чему я научилась:**
    - Написание тестов с бенчмарками с помощью pytest
    - Работа с классами и словарями в Python

### Описание решения
### Факториал и Фибоначчи


### Сортировки


### Очередь
Очередь реализована на связанном списке с принципом FIFO. Элементы хранятся в узлах (вспомогательный класс Node), каждый содержит значение и ссылку на следующий узел. Методы класса:
- enqueue(x) — добавляет элемент в конец
- dequeue() — удаляет и возвращает первый элемент (выбрасывает IndexError при пустой очереди)
- front() — возвращает первый элемент без удаления (выбрасывает IndexError при пустой)
- is_empty() — проверяет пустоту очереди
- \_\_len\_\_() — возвращает количество элементов

Все операции выполняются за O(1). Класс использует указатели head (первый элемент) и tail (последний элемент). При выполнении программы созданные очереди хранятся в словаре, где ключ — имя очереди, значение — экземпляр Queue.

### Дополнительно


## Интересные тест-кейсы
 - Сортировка пустого списка
 - 

## Инструкция к использованию

### Установить репозиторий
```pip install -e https://github.com/miniMlena/lab3_python#egg=lab3-medium``` \
```cd src/lab3-medium```

### Запустить

Основная программа: ```python -m src.main```

Тесты: ```pytest```

### Синтаксис
* Элементы очереди или списка для сортировки вводятся в квадратных скобках через запятую и пробел.
* При вводе генератора списка сначала вводится название генератора и затем через пробел числовые аргументы к нему.
* Памарметры key, cmp, base, buckets (ключ, компаратор, основание СС, количество корзин) можно указывать в любом порядке, формат их ввода: ```param=<param_value>```
Примеры ввода сортировок:
  ```bubble_sort rand_int_array 10 -100 100 key=abs cmp=odd_first```
  ```radix_sort_int ['', 'apple', 'my', 'you'] base=8 key=len```
  ```bucket_sort rand_float_array 5 0.0 1.0 buckets=3```
Примеры ввода для очереди:
```create new_qu [1, 2, 'abc']```
```create new_queue reverse_sorted 5```
Подробнее о синтаксисе всех доступных команд можно узнать, введя команду info в программе.
