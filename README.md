# Лабораторная работа 3
## Вариант: Medium (CLI, ключи, компараторы, бенчмарки, генерация тест-кейсов)

Моисеенко Милена Алексеевна, группа М8О-101БВ-25

* **Цель:** Написать функции подсчёта факториала, чисел Фибоначчи и сортировки списков с поддержкой ключей и компараторов на Python, реализовать одну из структур данных (я выбрала очередь), а также написать функции для бенчмарок и генераторы тест-койсов.
* **Библиотеки:** *typing*, *functools*, *sys*, *time*, *random*, *pytest*
* **Допущения:**
  - Элементами очередей и списков для сортировки могут быть только числа и строки. Вложенные списки/кортежи и т.д. не поддерживаются.
  - Можно пользоваться только предусмотренными в прграмме ключами и компараторами, свои создавать нельзя.
  - При тестировании бенчмарки для сортировок и факториалов/Фибоначчи выводятся вперемешку (там используются бенчмарки, встроенные в pytest). Чтобы посмотреть раздельные бенчмарки, можно ввести команду benchmark в самой программе (выведутся мои кастомные бенчмарки).

* **Чему я научилась:**
    - Написание тестов с бенчмарками с помощью pytest
    - Работа с классами и словарями в Python

### Описание решения
### Факториал и Фибоначчи
Реализовано по 2 варианта на каждую функцию: вариант, использующий цикл для подсчета, и вариант, использующий рекурсию. По бенчмаркам (команда benchmark) видно, что вариант с циклом работает быстрее.

### Сортировки
Все виды сортировок поддерживают ключи, компараторы поддерживают те, в которых используется операция сравнения: пузырьковая, быстрая, кучей. Список доступных ключей и компараторов можно увидеть, введя команду info в программе.

* Пузырьковая сортировка (bubble sort)
  
  Принцип работы:
  
  На каждой итерации проходим по списку слева направо, после для каждой пары соседних элементов вычисляем ключи через функцию key(element). Затем сравниваем полученные ключи с помощью компаратора comparator(key1, key2). Если компаратор указывает на необходимость обмена, меняем элементы местами. После первой итерации элемент с наибольшим ключом окажется на месте. Повторяем процесс для оставшейся части списка до полной сортировки.
  
  Сложность:
  - Лучший случай: O(n) — когда массив уже отсортирован
  - Средний случай: O(n²)
  - Худший случай: O(n²)

* Быстрая сортировка (quick sort)
  
  Принцип работы:
  
  Выбирается средний элемент подмассива в качестве опорного (pivot). Затем элементы массива сравниваются с pivot с помощью функции compare, построенной на основе key и компаратора cmp. Все элементы меньше или равные pivot перемещаются влево, а остальные вправо. Опорный элемент ставится на позицию между меньшими и большими элементами. Рекурсивно применяется тот же процесс к левому и правому подмассивам до полной сортировки.

  Сложность:
  
  - Лучший случай: O(n log n)
  - Средний случай: O(n log n)
  - Худший случай: O(n²) — при неудачном выборе опорного элемента

* Сортировка счетом (counting sort)
  
  Принцип работы:
  
  Вычисляются ключи для всех элементов списка через функцию key. Находятся минимальное и максимальное значения ключей. Создается массив счетчиков размером равным диапазону значений. Проходим по ключам и увеличиваем соответствующие счетчики. Вычисляем префиксные суммы для определения позиций элементов в результате. Проходим по исходному списку в обратном порядке, размещая каждый элемент в выходном массиве по позиции из префиксной суммы и уменьшая счетчик.

  Сложность:
  
  - Лучший случай: O(n + k) — где k это диапазон значений ключей
  - Средний случай: O(n + k)
  - Худший случай: O(n + k) — когда диапазон ключей велик

* Порязрядная сортировка для целых (radix_int)
  
  Принцип работы:
  
  Создаются пары (оригинальный_элемент, значение_для_сортировки) через функцию key. Определяется максимальное количество цифр в значениях. Поочередно для каждого разряда справа налево вычисляется цифра каждого элемента в этом разряде и элементы распределяются по корзинам по значению цифры в рассматриваемом разряде. После обработки всех позиций собирается отсортированный список из пар, сохраняя оригинальные элементы.

  Сложность:
  - Лучший случай: O(nk) — где k количество цифр
  - Средний случай: O(nk)
  - Худший случай: O(nk)
    
* Порязрядная сортировка для строк (radix_str)
  
  Принцип работы:
  Создаются пары (оригинальный_элемент, строковое_значение_для_сортировки) через функцию key. Определяется максимальная длина строк. Поочередно для каждой позиции символа справа налево вычисляется код символа с помощью ord(). Элементы распределяются по 256 корзинам по коду ASCII символа. После обработки всех позиций собирается отсортированный список из пар, сохраняя оригинальные элементы.
  
  Сложность:
  - Лучший случай: O(nk) — где k максимальная длина строки
  - Средний случай: O(nk)
  - Худший случай: O(nk)

* Корзинная сортировка (bucket sort)

  Принцип работы:

  Сортировка разбивает входной список на несколько "корзин", их количество передается как парметр функции. Для каждого элемента вычисляется ключ и нормализуется в диапазон. Затем элемент добавляется в соответствующую корзину. Каждая корзина затем сортируется быстрой сортировкой с использованием того же ключа. После сортировки всех корзин, элементы собираются в итоговый отсортированный список.
  
  Сложность:
  - Лучший случай: O(n + k) — когда значения распределены равномерно и корзин немного
  - Средний случай: зависит от сортировки внутри корзин, в данном случае O(n log n) из-за быстрой сортировки
  - Худший случай: O(n log n) — когда все элементы попадают в одну корзину
    
  Ограничения: Работает только с неотрицательными числами (целыми или с плавающей точкой) или с объектами, для которых ключ выдаёт такие значения
    
* Сортировка кучей (heap sort)
  
  Принцип работы:
  
  Сначала строится максимальная куча из элементов списка, сравнивая элементы через функцию compare, образованную на основе key и компаратора cmp. Для этого каждый узел сравнивается с потомками, и при необходимости происходит обмен с большим потомком. После построения кучи, максимальный элемент (корень) меняется местами с элементом в конце списка, размер кучи уменьшается, и куча восстанавливается заново. Процесс повторяется, пока весь список не будет отсортирован.

  Сложность:
  
  - Лучший случай: O(n log n)
  - Средний случай: O(n log n)
  - Худший случай: O(n log n)

И в моих бенчмарках, и в бенчмарках pytest видно, какие сортировки быстрее, а какие медленнее, и результаты вполне схожи с оценкой алгоритмической сложности (хотя поддержка ключей и компараторов замедляет сортировки).

### Очередь
Очередь реализована на связанном списке с принципом FIFO. Элементы хранятся в узлах (вспомогательный класс Node), каждый содержит значение и ссылку на следующий узел. Методы класса:
- enqueue(x) — добавляет элемент в конец
- dequeue() — удаляет и возвращает первый элемент (выбрасывает IndexError при пустой очереди)
- front() — возвращает первый элемент без удаления (выбрасывает IndexError при пустой)
- is_empty() — проверяет пустоту очереди
- \_\_len\_\_() — возвращает количество элементов

Все операции выполняются за O(1). Класс использует указатели head (первый элемент) и tail (последний элемент). При выполнении программы созданные очереди хранятся в словаре, где ключ — имя очереди, значение — экземпляр Queue.

### Дополнительно
 * CLI - можно вводить команды в терминал, их список и синтаксис можно почмотреть, введя команду info.
 * Генерация тест-кейсов

  Реализовано 5 функций для генерации списков разных типов. Они используются в бенчмарках (и моих, и pytest), а также из можно вызвать при вводе команды сортировки или при создании очереди.
   
 * Бенчмарки

  При вводе команды benchmark можно посмотреть бенчмарки для факториалов, Фибоначчи и сортировок. Для сортировок они каждый раз считаются на новых случайных данных, сгенерированных с помощью генераторов тест-кейсов. Можно сравнить скорости разных алгоритмов сортировки, сравнить со встроенной сортировкой, а также оценить масштабируемость (каждый алгоритм запускается на списках разных размеров). Есть также встроенные бенчмарки pytest, их можно увидеть при запуске тестов. 

## Интересные тест-кейсы
 - Сортировка пустого списка
 - Использование key=as_strings для сортировки списка чисел

## Инструкция к использованию

### Установить репозиторий
```pip install -e git+https://github.com/miniMlena/lab3_python.git#egg=labs```

```cd src/labs```

или:

```git clone https://github.com/miniMlena/lab3_python```

```cd lab3_python```

### Запустить

Основная программа: ```python -m src.main```

Тесты: ```pytest```

### Синтаксис
* Элементы очереди или списка для сортировки вводятся в квадратных скобках через запятую и пробел.
* При вводе генератора списка сначала вводится название генератора и затем через пробел числовые аргументы к нему.
* Памарметры key, cmp, base, buckets (ключ, компаратор, основание СС, количество корзин) можно указывать в любом порядке, формат их ввода: ```param=<param_value>```

Примеры ввода сортировок:

  ```bubble_sort rand_int_array 10 -100 100 key=abs cmp=odd_first```
  
  ```radix_sort_int ['', 'apple', 'my', 'you'] base=8 key=len```
  
  ```bucket_sort rand_float_array 5 0.0 1.0 buckets=3```

Примеры ввода для очереди:

```create new_qu [1, 2, 'abc']```

```create new_queue reverse_sorted 5```

Подробнее о синтаксисе всех доступных команд можно узнать, введя команду info в программе.
