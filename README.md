Сигнатуры функций сортировки взяты из файла с описанием ЛР. В них указано, что в списке, который передается функции, все элементы имеют одинаковый тип (arr: list[T]), но на самом деле они могут иметь разные типы, если будет введен подходящий ключ или компаратор. Например, если взять key=str, то все элементы будут сортироваться как строки, даже если изначально каике-то из них были, например, int

Разные base в radix могут ускорить сортировку

В рекурсивном Фибоначчи использован декоратор @functools.cache, т.к. без него функция считала максимум 40 элемент

Бенчмарки в тестах показывают, что пузырьковая сортировка - самая быстрая, хотя обычно наоборот считается самой медленной. Все дело в ключах и компараторах, для поддержки которых в большинстве случаев необходимо ещё раз проходится по списку элементов, в некоторых случаях создавать дополнительный список значений для сортировки, проводить валидацию получившегося списка, банально применить ключ/компаратор и так далее. Все это тратит очень много времени. И особенность пузырьковой сортировки в том, что ее алгоритм не требует дополнительного прохода по списку или чего-то подобного. К тому же в моей реализации она останавливается, если никаких перестановок не произошло на каком-то из проходов, что позволяет раньше закончить процесс.

В бенчмарках есть и масштабируемость
в pytest бенчмарках все в перемешку